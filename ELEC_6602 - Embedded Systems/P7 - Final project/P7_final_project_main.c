//**************************************************************************************************
// Project 7 - Interrupts
// Name: Howard Zhou
// Due Date: 05/2/2022
// Course: ELEC 6602 - Embedded Systems

// Description: 
//                  Program demonstrates uses of External interrupts PA4 and PA6.
//                  and internal software(SWIER) and TIMER2 interrupts.
//                  PORTD/H LEDs will display counter every 1 sec and can be paused/resumed with PA4
//                  Pressing PB6 will display the current count on the Terminal window.
//                  Keyboard input from the terminal window will increase the count displyed on
//                  PORTE LEDS. A seperate software interrupt will blink the LEDs on PORTD/L
//                  Independantly.
//      
//      Objective 1: - Use Timer 2, PA4 and PA6 on interrupt
//                   - Timer 2 will display the time every 1 second on PORTD/H 
//                     starting at 99, counting down to zero and restart.
//
//      Objective 2: - Every time PA4 is pressed for the first time, timer must stop.
//                   - When pressed a second time, it must start again.
//  
//      Objective 3: - When PB6 is released time must be displayed on USART Terminal (limit 00 to 99)
//                   - THe main program increments the value on PORTR every time a char
//                     is typed on USART terminal and sends the character back to 
//                     the USART terminal.
//
//      Bonus Obj:     Write and additional ISR to blink an LED at a specified frequency.
//
// **NOTE board requires all bitwise operations greater than 16 to either be accessed directly or 
//   re-casted to 32bit 
//**************************************************************************************************
// Project name:      P7_final_project.mcpar
// Generated by:      Visual TFT
// Test configuration:
//   MCU:             STM32F107VC
//   Dev.Board:       EasyMx_PRO_v7_for_STM32_ARM_9A - USE THIS PROFILE
//   Oscillator:      72000000 Hz
//   SW:              mikroC PRO for ARM
//                    http://www.mikroe.com/mikroc/arm/
///
//**************************************************************************************************

#include <stdint.h>
#include "P7_final_project_objects.h"

/// My headers
#include "cp_screen_ctl.h"

static const uint32_t GPIO_INPUT_MASK      = 0x44444444;
static const uint8_t PHASE_INTRO          = 0;
static const uint8_t PHASE_GAME           = 1; 
static const uint8_t TRUE                 = 1;
static const uint8_t FALSE                = 0;


/* Globals */
static volatile uint8_t _DEV_MODE   = FALSE;
static volatile uint8_t _GAME_PHASE = PHASE_INTRO;         // 0=intro screen; 1=main game

/* Interrupt Handlers */
void JOYSTICK_EXTI13 iv IVT_INT_EXIT


//============================================================================================================
/* Helper Functions */

/// Initialize MCU
void init_MCU() {
    /* Initialization MCU*/
    
    USART1_CR1 &= ~(1 << 13);                  // Disable USART for configuration

    AFIO_MAPR    = 0x00000000;                 // Bit[2] USART1 Remap 0: No remap remap timer2 stuff
    RCC_APB2ENR |= 0x00000001;                 // Alt. function bit to enable USART1

    RCC_APB2ENR |=  1 << 2;                    // Enable GPIO clock for PORT A 
    RCC_APB2ENR |=  1 << 3;                    // Enable GPIO clock for PORT B
    RCC_APB2ENR |=  1 << 4;                    // Enable GPIO clock for PORT C 
    RCC_APB2ENR |=  1 << 5;                    // Enable GPIO clock for PORT D 
    RCC_APB2ENR |=  1 << 6;                    // Enable GPIO clock for PORT E 
    RCC_APB2ENR |=  1 << 14;                   // Enable GPIO clock for USART1

    /* Config port direction & flags */
    GPIOA_CRL = GPIO_INPUT_MASK;                     // Enable PA2 PA4 PA5 PA6 for joystick control
    GPIOE_CRH = 0xFF00; 

    /* Joystick configuration */
    // PD2=Left, PD4=Up, PA6=Right, PB5=Down, PC13=J_button; 
    GPIOA_CRL |= 4 << 6;                       // Enable PA6;  joystick=RIGHT      
    GPIOB_CRL |= 4 << 5;                       // Enable PB5;  joystick=DOWN      
    GPIOD_CRL |= 4 << 2;                       // Enable PD2;  joystick=LEFT      
    GPIOD_CRL |= 4 << 4;                       // Enable PD4;  joystick=UP      
    GPIOC_CRH |= 4 << 5;                       // Enable PC13; joystick=PUSH BUTTON 
}

/// Configure USART1
void config_USART1() {
    GPIOA_CRH &= ~(0xFF << 4);                  // Shift 4 bits left to clear out bits PA9/PA10 mask with FFFF F00F
    GPIOA_CRH |=  (0x0B << 4);                  // USART1 Tx/PA9 set CNF=AF output push-pull b10; MODE: 50Hz b11; = b1011 = 0x0b
    GPIOA_CRH |=  (0x04 << 8);                  // USART1 Rx/PA10 set CNF=input-floating b01; MODE: input b00; = b0100 = 0x04

    /* Configure USART Baudrate */
    USART1_BRR = 0x00000506;                    // Clock=72MHz, oversample=16; 72MHz / (16*56,000) = 80.357
                                                // Mantissa=80=0x50; Fraction=(0.357 *16) = 5.7 ~ 0x6; Baud reg = 0x506    

    /* USART Control register configuration */
    USART1_CR1 &= ~(1 << 13);                   // Disable USART for configuration
    USART1_CR1 |= 1 << 5;                       // ENABLE USART1 TXNE interrupt
    USART1_CR1 &= ~(1 << 12);                   // Force 8 data bits. Mbit set to 0
    USART1_CR1 &= ~(3 << 9);                    // Force no Parity & no parity control
    USART1_CR2 &= ~(3 << 12);                   // Force 1 stop bit
    USART1_CR3 &= ~(3 << 8);                    // Force no flow control and no DMA for USART1
    USART1_CR1 |=  3 << 2;                      // Rx, Tx Enable

    Delay_ms(100);                              // Allow time for USART1 to complete initialization
    USART1_CR1 |= 1 << 13;                      // **NOTE: USART1 Enable must be done after configuration is complete. 
}

/// Initialize TIMER2
void init_timer2() {
    RCC_APB1ENR |= 1 << 0;                      // Enable Clock for TIMER2 
    TIM2_CR1 = 0x0000;                          // Disable the timer for config setup
    TIM2_PSC = 7999;                            // Counter clock freq is equal to clk_PSC / (PSC[15:0] + 1) from datasheet
                                                // We want 72MHz / (7999+1) = 9000 Num. clk cycles/sec
    TIM2_ARR = 9000;                            // Set the auto-reload register to calclated value
    TIME2_DIER |= 1 << 0;                       // Enable TIMER2 Interrupt 
    TIM2_CR1 = 0x0001;                          // After timer setup, enable TIMER2 bit[1]; bit[4]=0 counting up.
}


/// Initialize and configure Interrupts
void init_interrupt() {


    // Reset the register to put it in a known state
    AFIO_EXTICR2 = 0x0000;          
    NVIC_ISER0   = 0x00000000;      


    // PD2=Left, PD4=Up, PA6=Right, PB5=Down, PC13=J_button; 
    AFIO_EXTICR1 |= 3 << 8;                     // PD2 = EXTI2[11:8]; PortD = b0011;
    AFIO_EXTICR2 |= 3 << 0;                     // PD4 = EXTI4[3:0];  PortD = b0011;
    AFIO_EXTICR2 |= 1 << 4;                     // PB5 = EXTI5[7:4];  PortB = b0001;
    AFIO_EXTICR2 &= ~(0xF << 0);                // PA6 = EXTI6[3:0];  PortA = b0000;
    AFIO_EXTICR4 |= 2 << 4;                     // PC13  EXTI13[7:4]; PortC = b0010;


    /* Vector NVIC mapping enable - see ref. manual 10.1.2 -IRQ & Exception Vector table for mapping*/
    // Set bit for Interrupt set-enable registers for EXTI2=8; EXTI4=10; EXTI5 & EXIT6=23(EXIT9_5); EXTI13 (EXTI_15_10)=40
    NVIC_ISER0 |= (uint32_t) 1 << 8;
    NVIC_ISER0 |= (uint32_t) 1 << 10;
    NVIC_ISER0 |= (uint32_t) 1 << 23;
    NVIC_ISER1 |= (uint32_t) 1 << 8;


}

//============================================================================================================
/* Main function */
void main() {

    /* Local Variables */
    // uint32_t counter = 0;
  
    /* Initialize GPIO & USART */
    init_MCU();
    
    /* Configure USART1 port direction & flags */
    config_USART1();

    

    /* TIMER2 setup configuration */
   init_timer2();


    /* Interrupt setup and configuration */
    init_interrupt();
   
   
    /* Display Initializatiogitn */
    Start_TP();


    /* Display execution stuff */

    /* Intro screen */
    load_intro_screen();
 
    // ***Game mode starts here**

                    

    // TFT_SET_Brush(1, CL_RED, 0, 0, 0 ,0);
    // TFT_Rectangle(0, 0, 320, 240);
    // TFT_Fill_Screen(CL_RED);

    while (1) {
        Check_TP();
    }
}
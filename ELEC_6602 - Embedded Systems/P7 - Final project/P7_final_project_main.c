//**************************************************************************************************
// Project 7 - Interrupts
// Name: Howard Zhou
// Due Date: 05/2/2022
// Course: ELEC 6602 - Embedded Systems

// Description: 
//                  Program demonstrates uses of External interrupts PA4 and PA6.
//                  and internal software(SWIER) and TIMER2 interrupts.
//                  PORTD/H LEDs will display counter every 1 sec and can be paused/resumed with PA4
//                  Pressing PB6 will display the current count on the Terminal window.
//                  Keyboard input from the terminal window will increase the count displyed on
//                  PORTE LEDS. A seperate software interrupt will blink the LEDs on PORTD/L
//                  Independantly.
//      
//      Objective 1: - Use Timer 2, PA4 and PA6 on interrupt
//                   - Timer 2 will display the time every 1 second on PORTD/H 
//                     starting at 99, counting down to zero and restart.
//
//      Objective 2: - Every time PA4 is pressed for the first time, timer must stop.
//                   - When pressed a second time, it must start again.
//  
//      Objective 3: - When PB6 is released time must be displayed on USART Terminal (limit 00 to 99)
//                   - THe main program increments the value on PORTR every time a char
//                     is typed on USART terminal and sends the character back to 
//                     the USART terminal.
//
//      Bonus Obj:     Write and additional ISR to blink an LED at a specified frequency.
//
// **NOTE board requires all bitwise operations greater than 16 to either be accessed directly or 
//   re-casted to 32bit 
//**************************************************************************************************
// Project name:      P7_final_project.mcpar
// Generated by:      Visual TFT
// Test configuration:
//   MCU:             STM32F107VC
//   Dev.Board:       EasyMx_PRO_v7_for_STM32_ARM_9A - USE THIS PROFILE
//   Oscillator:      72000000 Hz
//   SW:              mikroC PRO for ARM
//                    http://www.mikroe.com/mikroc/arm/

 // GPIOE_ODR = (~GPIOE_ODR) |  1 << 9;
            // Delay_ms(1000);
///
//**************************************************************************************************

#include <stdint.h>
#include <stdlib.h>

/// Local headers
#include "P7_final_project_objects.h"
#include "cp_const_def.h"
#include "cp_intro_screen_ctl.h"
#include "cp_game_ctl.h"




/* Global variables*/
static volatile uint8_t DEV_MODE   = FALSE;
static volatile uint8_t GAME_PHASE  = PHASE_INTRO;         // 0=intro screen; 1=main game

uint32_t rx_buffer = 0;


/* Interrupt Handlers */

/// USART1 Tx Interrupt
// Bit7 TXE; Bit6 TC;  
// TCIE interrupt generated in USART_CR1; Cleared by read  from USART_SR followed by wrte to USART_DR
// void USART1_ISR() iv IVT_INT_USART1 {
//     while ((USART1_SR & (1 << 7)) == 1)   {}     // Wait for TXE to clear
//     //  USART1_SR &= ~(1 << 7);
//     USART1_SR &= ~(0x3 << 6);
//     //  rx_buffer = USART1_SR;
//     //  USART1_DR = 0x50;
//     Delay_ms(10);

// }


// PC13 Joystick_button ISR
void EXTI15_10() iv IVT_INT_EXTI15_10  {
    

    if (GAME_PHASE == PHASE_INTRO) {
        while (GPIOC_IDR.B13 == 0) {} 

        EXTI_PR |= 1 << 15;
        // while (GPIOC_IDR.B13 == 0) {} 
        // GPIOB_ODR = ~GPIOB_ODR; 
        GPIOB_ODR = ~GPIOB_ODR;

        set_cur_screen_run_flag(FALSE);
        GAME_PHASE = PHASE_GAME1;
    }
    else if (GAME_PHASE == PHASE_GAME1) {
         set_cur_screen_run_flag(FALSE);
        GAME_PHASE = PHASE_GAME2;

    }
}




//============================================================================================================
/* Helper Functions */

/// Initialize and configure MCU clocks and gpio
void init_cfg_M_CTL() {
    /* Initialization MCU*/
    
    USART1_CR1 &= ~(1 << 13);                  // Disable USART for configuration

    AFIO_MAPR    = 0x00000000;                 // Bit[2] USART1 Remap 0: No remap remap timer2 stuff
    RCC_APB2ENR |= 0x00000001;                 // Alt. function bit to enable USART1

    RCC_APB2ENR |= 1 << 2;                    // Enable GPIO clock for PORT A 
    RCC_APB2ENR |= 1 << 3;                    // Enable GPIO clock for PORT B
    RCC_APB2ENR |= 1 << 4;                    // Enable GPIO clock for PORT C 
    RCC_APB2ENR |= 1 << 5;                    // Enable GPIO clock for PORT D 
    RCC_APB2ENR |= 1 << 6;                    // Enable GPIO clock for PORT E 
    RCC_APB2ENR |= 1 << 14;                   // Enable GPIO clock for USART1

    /* Config port direction & flags */
    GPIOA_CRL = GPIO_INPUT_MASK;                     // Enable PA2 PA4 PA5 PA6 for joystick control
    GPIOE_CRH = 0xFF00; 

    /* Joystick configuration */
    GPIOA_CRL |= 4 << 6;                       // Enable PA6;  joystick=RIGHT      
    GPIOB_CRL |= 4 << 5;                       // Enable PB5;  joystick=DOWN      
    GPIOD_CRL |= 4 << 2;                       // Enable PD2;  joystick=LEFT      
    GPIOD_CRL |= 4 << 4;                       // Enable PD4;  joystick=UP      
    GPIOC_CRH |= 4 << 5;                       // Enable PC13; joystick=PUSH BUTTON 
}

/// Configure USART1
void config_USART1() {
    GPIOA_CRH &= ~(0xFF << 4);                  // Shift 4 bits left to clear out bits PA9/PA10 mask with FFFF F00F
    GPIOA_CRH |=  (0x0B << 4);                  // USART1 Tx/PA9 set CNF=AF output push-pull b10; MODE: 50Hz b11; = b1011 = 0x0b
    GPIOA_CRH |=  (0x04 << 8);                  // USART1 Rx/PA10 set CNF=input-floating b01; MODE: input b00; = b0100 = 0x04

    /* Configure USART Baudrate */
    USART1_BRR = 0x00000506;                    // Clock=72MHz, oversample=16; 72MHz / (16*56,000) = 80.357
                                                // Mantissa=80=0x50; Fraction=(0.357 *16) = 5.7 ~ 0x6; Baud reg = 0x506    

    /* USART Control register configuration */
    USART1_CR1 &= ~(1 << 13);                   // Disable USART for configuration
    // USART1_CR1 |=   1 << 7;                     // ENABLE USART1 TXNE interrupt
    USART1_CR1 &= ~(1 << 12);                   // Force 8 data bits. Mbit set to 0
    USART1_CR1 &= ~(3 << 9);                    // Force no Parity & no parity control
    USART1_CR2 &= ~(3 << 12);                   // Force 1 stop bit
    USART1_CR3 &= ~(3 << 8);                    // Force no flow control and no DMA for USART1

    USART1_CR1 |=   1 << 3;                     // Tx Enable
    USART1_CR1 |=   1 << 2;                     // Rx Enable

    Delay_ms(100);                              // Allow time for USART1 to complete initialization
    USART1_CR1 |= 1 << 13;                      // **NOTE: USART1 Enable must be done after configuration is complete. 
}

/// Initialize TIMER1

/// Initialize TIMER2
void init_timer2() {
    RCC_APB1ENR |= 1 << 0;                      // Enable Clock for TIMER2 
    TIM2_CR1     = 0x0000;                      // Disable the timer for config setup
    TIM2_PSC     = 7999;                        // Counter clock freq is equal to clk_PSC / (PSC[15:0] + 1) from datasheet
                                                // We want 72MHz / (7999+1) = 9000 Num. clk cycles/sec
    TIM2_ARR     = 9000;                        // Set the auto-reload register to calclated value
    TIM2_DIER  |= 1 << 0;                      // Enable TIMER2 Interrupt 
    TIM2_CR1     = 0x0001;                      // After timer setup, enable TIMER2 bit[1]; bit[4]=0 counting up.
}


/// Initialize and configure Interrupts
void init_interrupt() {

    // Reset the register to put it in a known state
    AFIO_EXTICR2 = 0x0000;          
    NVIC_ISER0   = 0x00000000;      

    // PD2=Left, PD4=Up, PA6=Right, PB5=Down, PC13=J_button; 
    AFIO_EXTICR1 |= 3 << 8;                     // PD2 = EXTI2[11:8]; PortD = b0011;
    AFIO_EXTICR2 |= 3 << 0;                     // PD4 = EXTI4[3:0];  PortD = b0011;
    AFIO_EXTICR2 |= 1 << 4;                     // PB5 = EXTI5[7:4];  PortB = b0001;
    AFIO_EXTICR2 &= ~(0xF << 0);                // PA6 = EXTI6[3:0];  PortA = b0000;
    AFIO_EXTICR4 |= 2 << 4;                     // PC13  EXTI13[7:4]; PortC = b0010;


    // Configure edge trigger and maskability and mask enable
    EXTI_FTSR |= 1 << 13; // EXTI13 is FALLING EDGE
    // EXTI_RTSR |= 
    EXTI_IMR |= 0x00002074;      // Set EXTI2,4,5,6,13 to not-maskable


    /* Vector NVIC mapping enable - see ref. manual 10.1.2 -IRQ & Exception Vector table for mapping*/
    // Set bit for Interrupt set-enable registers for EXTI2=8; EXTI4=10; EXTI5 & EXIT6=23(EXIT9_5); EXTI13 (EXTI_15_10)=40
    NVIC_ISER0 |= (uint32_t) 1 << 8;            // EXTI2  NVIC Pos=8:  
    NVIC_ISER0 |= (uint32_t) 1 << 10;           // EXTI4  NVIC Pos=10: 
    NVIC_ISER0 |= (uint32_t) 1 << 23;           // EXTI5  NVIC Pos=23: EXTI9_5 
    NVIC_ISER1 |= (uint32_t) 1 << 8;            // EXTI13 NVIC Pos=40: EXTI15_10
    NVIC_ISER1 |= (uint32_t) 1 << 5;            // USART1 NVIC Pos=37: ISER1[63:32]; 32+5 =37

}

void debug(uint32_t value) {
    Delay_ms(1);
    USART1_DR = 0xD;
    Delay_ms(1);
    USART1_DR=0xA;
    Delay_ms(1);
    USART1_DR = value;
}

uint32_t rand_num_gen() {
    uint32_t ret = 0;
    ret = TIM2_CNT % 100;
    return ret ; 
}

//============================================================================================================
/* Main function */
void main() {

    /* Local Variables */
    // uint32_t counter = 0;
    int num =0;

    /* Initialize GPIO & USART */
    init_cfg_M_CTL();

    /* Configure USART1 port direction & flags */
    config_USART1();



    /* TIMER2 setup configuration */
    init_timer2();


    /* Interrupt setup and configuration */
    init_interrupt();


    /* Display Initializatiogitn */
    Start_TP();


    /* Display execution stuff */

 
    /* Intro screen */
    load_intro_screen();
    debug( rand_num_gen() );
    debug( rand_num_gen() );
    debug( rand_num_gen() );

    // ***Game mode starts here**
    load_game_screen();
                    

    TFT_SET_Brush(1, CL_RED, 0, 0, 0 ,0);
    TFT_Rectangle(0, 0, 320, 240);
    TFT_Fill_Screen(CL_RED);

    Delay_ms(3000);

    while (1) {
        // Check_TP();
    }
}
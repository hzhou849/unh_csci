//**************************************************************************************************
// Project 7 - Interrupts
// Name: Howard Zhou
// Due Date: 05/2/2022
// Course: ELEC 6602 - Embedded Systems

// Description: 
//                  Program demonstrates uses of External interrupts PA4 and PA6.
//                  and internal software(SWIER) and TIMER2 interrupts.
//                  PORTD/H LEDs will display counter every 1 sec and can be paused/resumed with PA4
//                  Pressing PB6 will display the current count on the Terminal window.
//                  Keyboard input from the terminal window will increase the count displyed on
//                  PORTE LEDS. A seperate software interrupt will blink the LEDs on PORTD/L
//                  Independantly.
//      
//      Objective 1: - Use Timer 2, PA4 and PA6 on interrupt
//                   - Timer 2 will display the time every 1 second on PORTD/H 
//                     starting at 99, counting down to zero and restart.
//
//      Objective 2: - Every time PA4 is pressed for the first time, timer must stop.
//                   - When pressed a second time, it must start again.
//  
//      Objective 3: - When PB6 is released time must be displayed on USART Terminal (limit 00 to 99)
//                   - THe main program increments the value on PORTR every time a char
//                     is typed on USART terminal and sends the character back to 
//                     the USART terminal.
//
//      Bonus Obj:     Write and additional ISR to blink an LED at a specified frequency.
//
// **NOTE board requires all bitwise operations greater than 16 to either be accessed directly or 
//   re-casted to 32bit 
//**************************************************************************************************
// Project name:      P7_final_project.mcpar
// Generated by:      Visual TFT
// Test configuration:
//   MCU:             STM32F107VC
//   Dev.Board:       EasyMx_PRO_v7_for_STM32_ARM_9A - USE THIS PROFILE
//   Oscillator:      72000000 Hz
//   SW:              mikroC PRO for ARM
//                    http://www.mikroe.com/mikroc/arm/

 // GPIOE_ODR = (~GPIOE_ODR) |  1 << 9;
            // Delay_ms(1000);
///
//**************************************************************************************************

#include <stdint.h>
#include <stdlib.h>

/// Local headers
#include "P7_final_project_objects.h"
#include "cp_const_def.h"
#include "cp_intro_screen_ctl.h"
#include "cp_game_ctl.h"



/* Global variables*/
static volatile uint8_t DEV_MODE   = FALSE;
static uint8_t g_cur_game_phase  = 0xFF;         // 0=intro screen; 1=main game
static int32_t g_game_speed        = 1000;

uint32_t rx_buffer = 0;
uint32_t debug_val;


/* Interrupt Handlers */

/// USART1 Tx Interrupt
// Bit7 TXE; Bit6 TC;  
// TCIE interrupt generated in USART_CR1; Cleared by read  from USART_SR followed by wrte to USART_DR
// void USART1_ISR() iv IVT_INT_USART1 {
//     while ((USART1_SR & (1 << 7)) == 1)   {}     // Wait for TXE to clear
//     //  USART1_SR &= ~(1 << 7);
//     USART1_SR &= ~(0x3 << 6);
//     //  rx_buffer = USART1_SR;
//     //  USART1_DR = 0x50;
//     Delay_ms(10);

// }

// PD2 = EXTI2[11:8]; PortD = b0011;
// PD4 = EXTI4[3:0];  PortD = b0011;
// PB5 = EXTI5[7:4];  PortB = b0001;
// PA6 = EXTI6[3:0];  PortA = b0000;
// PC13  EXTI13[7:4]; PortC = b0010;


// PC13 Joystick_button ISR
void EXTI15_10() iv IVT_INT_EXTI15_10  {

    EXTI_PR |= 1 << 13;     // Rearm interrupt
    GPIOB_ODR = ~GPIOB_ODR;

    while (GPIOC_IDR.B13 == 0) { GPIOB_ODR = ~GPIOB_ODR; } 

    g_cur_game_phase = get_game_mode();

     switch (g_cur_game_phase)
    {
    case PHASE_INTRO:
        set_cur_screen_run_flag(FALSE);
        g_cur_game_phase = PHASE1_READY; // load_snake_game
        break;

    case PHASE1_READY:
        set_cur_screen_run_flag(FALSE);
        g_cur_game_phase = PHASE2_PLAYING;    // Start snake game
        break;
    
    case PHASE2_PLAYING:
        Delay_ms(100);
        // set_cur_screen_run_flag(FALSE); 

        // g_cur_game_phase = PHASE2_PLAYING;
        break;

    // case PHASE2_PLAYING:
    //     set_cur_screen_run_flag(FALSE); // Start snake game
    //     // g_cur_game_phase = PHASE2_PLAYING;
    //     break;
    
    default:
        break;
    }
    
    // if (g_cur_game_phase == PHASE_INTRO) {

    //     set_cur_screen_run_flag(FALSE);
    //     // g_cur_game_phase = PHASE1_READY;
    // }
    // else if (g_cur_game_phase == PHASE1_READY) {
    //     set_cur_screen_run_flag(FALSE);
    //     // g_cur_game_phase = PHASE2_PLAYING; // load_snake_game
    // }
    // else if (g_cur_game_phase == PHASE2_PLAYING) {
    //     // set_cur_screen_run_flag(FALSE);
    //     // g_cur_game_phase = PHASE2_PLAYING; // start_snake_game
        
    //     Delay_ms(100);
    // }
    // // else if (g_cur_game_phase == PHASE2_READY) {
    //     // set_cur_screen_run_flag(FALSE);
    //     // g_cur_game_phase = PHASE2_PLAYING; // start_snake_game
    //     // while playing
    // // }


}

// PA6 - Joystick Right ISR
void EXTIPA6() iv IVT_INT_EXTI9_5  {
    if (GPIOB_IDR.B5 == 0) {
        while(GPIOB_IDR.B5 == 0) {GPIOC_ODR = ~GPIOC_ODR;}
        EXTI_PR |= 1 << 5;
        set_curr_snake_dir(MOVE_DOWN);
    }
        
    
    if (GPIOA_IDR.B6 == 0) {
        EXTI_PR |= 1 << 6;
        while (GPIOA_IDR.B6 == 0) {
            GPIOB_ODR = ~GPIOB_ODR;
            Delay_ms(1);
        } 
        set_curr_snake_dir(MOVE_RIGHT);
        // Change speed
        // TIM3_CR1    = 0x0000;                       // Disable time for setup
        // g_game_speed -= 2000; // 500ms

        // if (g_game_speed <= 0) {
        //     g_game_speed = 1300; // Anything less will not be visible
        // }
        // TIM3_ARR = g_game_speed;
        // Delay_ms(10);
        // TIM3_CNT = TIM3_CNT % g_game_speed ; // Reset the count
        // TIM3_CR1 = 0x0001;  // REset the timer
        // Delay_ms(10);
        
    }

    // set_cur_screen_run_flag(FALSE);

}

// PD2 - Joystick LEFT ISR
void EXTIPD2() iv IVT_INT_EXTI2  {
    EXTI_PR |= 1 << 2;
     while (GPIOD_IDR.B2 == 0) {GPIOB_ODR = ~GPIOB_ODR;} 
     set_curr_snake_dir(MOVE_LEFT);

    
}

// PD4 - Joystick LEFT ISR
void EXTIPD4() iv IVT_INT_EXTI4  {
    EXTI_PR |= 1 << 4;
     while (GPIOD_IDR.B4 == 0) {GPIOB_ODR = ~GPIOB_ODR;} 
     set_curr_snake_dir(MOVE_UP);
}

/// TIMER2 ISR
void TIMER2_ISR() iv IVT_INT_TIM2 {
    TIM2_SR &= ~(1<<0);         // Bit[0] UIF interrupt reset set to 0
    update_game_time();


    //   /* clean screen mask */
    //update direction and refresh screen here?
    render_rect_mask(0,0,20,1, m_NAVY);
    Delay_ms(50);
    //  render_rect_mask(0,10,19,0, m_BLACK);
    // /* Update time */
    update_time();

    // /* Update score */
    update_score();
    // Delay_ms(100); // delay needed for screen to update
       //     // Update game mode
        //     sprintf(g_str_buffer, "MODE: \x20 DEV:\x20 %d",g_debug );
        //     TFT_Write_Text(&g_str_buffer, 7*PX_BLOCK, 0*PX_BLOCK);
    // Debug print to screen
    // read adc
    debug_val = ADC1_Read(3);
    // debug_val = ADC1_DR;
    //  scr_debug(debug_val);
    //  ADC1_SR = 0;
}

/// TIMER3 ISR - Needs to have higher priority than TIM2 in order to update display properly
void TIMER3_ISR() iv IVT_INT_TIM3 {
    TIM3_SR &= ~(1<<0);         // Bit[0] UIF interrupt reset set to 0
    toggle_game_clock_delay(); 
      // Clean previous buffered image out and update new movement
        // cleaning_buffer(m_BLACK);  
        //         Delay_ms(100);
        // move_snake();
        // dump_ds_buffer();  

    screen_refresh_TIM3();
}





//============================================================================================================
/* Helper Functions */

/// Initialize and configure MCU clocks and gpio
void init_cfg_M_CTL() {
    /* Initialization MCU*/
    
    USART1_CR1 &= ~(1 << 13);                  // Disable USART for configuration

    AFIO_MAPR    = 0x00000000;                 // Bit[2] USART1 Remap 0: No remap remap timer2 stuff
    RCC_APB2ENR |= 0x00000001;                 // Alt. function bit to enable USART1

    RCC_APB2ENR |= 1 << 2;                    // Enable GPIO clock for PORT A 
    RCC_APB2ENR |= 1 << 3;                    // Enable GPIO clock for PORT B
    RCC_APB2ENR |= 1 << 4;                    // Enable GPIO clock for PORT C 
    RCC_APB2ENR |= 1 << 5;                    // Enable GPIO clock for PORT D 
    RCC_APB2ENR |= 1 << 6;                    // Enable GPIO clock for PORT E 
    RCC_APB2ENR |= 1 << 14;                   // Enable GPIO clock for USART1
    RCC_APB2ENR |= 1 << 9;                   // Enable ADC1 Clock

    /* Config port direction & flags */
    GPIOE_CRH = 0xFF00; 
    GPIOA_CRL &= ~(0xF << 12);                 // PA3 - Analog input mode b0000 bit[15:12]

    /* Joystick configuration */
    GPIOA_CRL |= 4 << 4;                       // Enable PA4;  Game TIMER3 control      
    GPIOA_CRL |= 4 << 6;                       // Enable PA6;  joystick=RIGHT      
    GPIOB_CRL |= 4 << 5;                       // Enable PB5;  joystick=DOWN      
    GPIOD_CRL |= 4 << 2;                       // Enable PD2;  joystick=LEFT      
    GPIOD_CRL |= 4 << 4;                       // Enable PD4;  joystick=UP      
    GPIOC_CRH |= 4 << 5;                       // Enable PC13; joystick=PUSH BUTTON 

    // ADC1_Init();
    // ADC_Set_Input_Channel(_ADC_CHANNEL_3);
    // unsigned ADC_Get_Sample(_ADC_CHANNEL_3);

    // ADC1_CR1 |= 1 << 23; // Analog-watch-dog Enable watchdog;
    // ADC1_CR1 |= 1 << 16; // Analog-watch-dog Enable watchdog;
    // // ADC_CR1 |= 1 << 6; // AWD watchdog interrupt enable;
    // ADC1_CR1 |= 0x3 << 0; // AWD Channel 3 selection
    // ADC1_CR1 |= 1 << 0; // AWD Channel 1 selection

    // ADC1_CR2 |= 1 << 22; // Start conversion of regular channels
    // ADC1_CR2 |= (uint32_t) 1 << 21; // Start conversion of injected channels
    // ADC1_CR2 |= 1 << 20; // Exteral trigger conversion mode for regular channels
    // ADC1_CR2 = 0;
    // ADC1_CR2 |= (uint32_t) 1 << 12; // JWSTART b111
    // ADC1_CR2 |= (uint32_t) 1 << 13; // JWSTART b111
    // ADC1_CR2 |= (uint32_t) 1 << 14; // JWSTART b111
    // ADC1_CR2 |= 1 << 1; // ADC continuous conversion on
    // ADC1_JOFR1 |= 1 << 3; // enable channel 3 injection
    // ADC1_CR2 |= 1 << 0; // ADC on

    //ADC1_CR1 = 0x0001
    //ADC1_CR2 = 0x000E 0001 b0- 0- 1110 0- 0- 0001 | 14,13,12 & 1 = ON

    

}

/// Configure USART1
void config_USART1() {
    GPIOA_CRH &= ~(0xFF << 4);                  // Shift 4 bits left to clear out bits PA9/PA10 mask with FFFF F00F
    GPIOA_CRH |=  (0x0B << 4);                  // USART1 Tx/PA9 set CNF=AF output push-pull b10; MODE: 50Hz b11; = b1011 = 0x0b
    GPIOA_CRH |=  (0x04 << 8);                  // USART1 Rx/PA10 set CNF=input-floating b01; MODE: input b00; = b0100 = 0x04

    /* Configure USART Baudrate */
    USART1_BRR = 0x00000506;                    // Clock=72MHz, oversample=16; 72MHz / (16*56,000) = 80.357
                                                // Mantissa=80=0x50; Fraction=(0.357 *16) = 5.7 ~ 0x6; Baud reg = 0x506    

    /* USART Control register configuration */
    USART1_CR1 &= ~(1 << 13);                   // Disable USART for configuration
    // USART1_CR1 |=   1 << 7;                     // ENABLE USART1 TXNE interrupt
    USART1_CR1 &= ~(1 << 12);                   // Force 8 data bits. Mbit set to 0
    USART1_CR1 &= ~(3 << 9);                    // Force no Parity & no parity control
    USART1_CR2 &= ~(3 << 12);                   // Force 1 stop bit
    USART1_CR3 &= ~(3 << 8);                    // Force no flow control and no DMA for USART1

    USART1_CR1 |=   1 << 3;                     // Tx Enable
    USART1_CR1 |=   1 << 2;                     // Rx Enable

    Delay_ms(100);                              // Allow time for USART1 to complete initialization
    USART1_CR1 |= 1 << 13;                      // **NOTE: USART1 Enable must be done after configuration is complete. 


}

/// Initialize TIMER1


/// Initialize TIMER2
void init_timer2() {
    RCC_APB1ENR |= 1 << 0;                      // Enable Clock for TIMER2 
    TIM2_CR1     = 0x0000;                      // Disable the timer for config setup
    TIM2_PSC     = 7999;                        // Counter clock freq is equal to clk_PSC / (PSC[15:0] + 1) from datasheet
                                                // We want 72MHz / (7999+1) = 9000 Num. clk cycles/sec
    TIM2_ARR     = 9000;                        // Set the auto-reload register to calclated value
    TIM2_DIER  |= 1 << 0;                      // Enable TIMER2 Interrupt 
    // TIM2_CR1     = 0x0001;                      // wait for game to startAfter timer setup, enable TIMER2 bit[1]; bit[4]=0 counting up.
}

void init_timer3() {
    RCC_APB1ENR |= (1 << 1);                   // Enable TIMER3 Clock
    TIM3_CR1    = 0x0000;                       // Disable time for setup
    TIM3_PSC    = 7999;                         // Counter clock freq is equal to clk_PSC / (PSC[15:0] + 1) from datasheet
                                                // We want 72MHz / (7999+1) = 9000 Num. clk cycles/sec
    TIM3_ARR    = g_game_speed;                         // auto-reload reg. 2 seconds so  double it = 9000*2 = 18000                                            
    TIM3_DIER   |= 1 << 0;                      // Enable interrupt
    // TIM3_CR1     = 0x0001;                      // After timer setup, enable TIMER1 bit[1]; bit[4]=0 counting up.

}

/// Initialize and configure Interrupts
void init_interrupt() {

    // Reset the register to put it in a known state
    AFIO_EXTICR2 = 0x0000;          
    NVIC_ISER0   = 0x00000000;      

    // PD2=Left, PD4=Up, PA6=Right, PB5=Down, PC13=J_button; 
    // AFIO_EXTICR1 |=
    AFIO_EXTICR1 |= 3 << 8;                     // PD2 = EXTI2[11:8]; PortD = b0011;
    AFIO_EXTICR2 |= 3 << 0;                     // PD4 = EXTI4[3:0];  PortD = b0011;
    AFIO_EXTICR2 |= 1 << 4;                     // PB5 = EXTI5[7:4];  PortB = b0001;
    AFIO_EXTICR2 &= ~(0xF << 8);                // PA6 = EXTI6[3:0];  PortA = b0000;
    AFIO_EXTICR4 |= 2 << 4;                     // PC13  EXTI13[7:4]; PortC = b0010;


    // Configure edge trigger and maskability and mask enable
    EXTI_FTSR |= 1 << 2; // EXTI2 is FALLING EDGE
    EXTI_FTSR |= 1 << 4; // EXTI4 is FALLING EDGE
    EXTI_FTSR |= 1 << 5; // EXTI5 is FALLING EDGE
    EXTI_FTSR |= 1 << 6; // EXTI6 is FALLING EDGE
    EXTI_FTSR |= 1 << 13; // EXTI13 is FALLING EDGE
    // EXTI_FTSR |= 1 << 13; // EXTI13 is FALLING EDGE
    // EXTI_RTSR |= 
    EXTI_IMR |= 0x00002074;      // Set EXTI2,4,5,6,13 to not-maskable


    /* Vector NVIC mapping enable - see ref. manual 10.1.2 -IRQ & Exception Vector table for mapping*/
    // Set bit for Interrupt set-enable registers for EXTI2=8; EXTI4=10; EXTI5 & EXIT6=23(EXIT9_5); EXTI13 (EXTI_15_10)=40
    NVIC_ISER0 |= (uint32_t) 1 << 8;            // EXTI2  NVIC Pos=8:  
    NVIC_ISER0 |= (uint32_t) 1 << 10;           // EXTI4  NVIC Pos=10: 
    NVIC_ISER0 |= (uint32_t) 1 << 23;           // EXTI5  NVIC Pos=23: EXTI9_5 
    NVIC_ISER0 |= (uint32_t) 1 << 28;           // TIMER2  NVIC Pos=28
    NVIC_ISER0 |= (uint32_t) 1 << 29;           // TIMER3  NVIC Pos=29

    NVIC_ISER1 |= (uint32_t) 1 << 8;            // EXTI13 NVIC Pos=40: EXTI15_10
    NVIC_ISER1 |= (uint32_t) 1 << 5;            // USART1 NVIC Pos=37: ISER1[63:32]; 32+5 =37

    /* Interrupt Priority settings */
    
    // // TIMER 2 Priority 
    // NVIC_IPR7 |= (uint32_t) 0xFE << 0;
    // // TIMER3 is NVIC Pos 29
    // // 29 % 4 = 8 R 1; IPRx=8; offset=1 8bits/offset; 0-255(0xFF) priority
    // NVIC_IPR8 |= (uint32_t) 0xFF<< 1;


}


//============================================================================================================
/* Main function */
void main() {

    /* Local Variables */
    // uint32_t counter = 0;
    int num =0;

    /* Initialize GPIO & USART */
    init_cfg_M_CTL();

    /* Configure USART1 port direction & flags */
    config_USART1();



    /* TIMERS setup configuration */
    init_timer2();
    init_timer3();


    /* Interrupt setup and configuration */
    init_interrupt();


    /* Display Initializatiogitn */
    Start_TP();


    /* Display execution stuff */

 
    /* Intro screen */
    // load_intro_screen();


    /* **Game mode starts here* */
    // load_duck_screen();

    load_snake_game();

    // initialize the screen ** NOTE this load sequence must be performed in this order
    // of screen will have issues. 
    init_snake_game();      

    TIM2_CR1     = 0x0001; // Start TIMER2 for game time
    TIM3_CR1    = 0x0001; // Start TIMER3 now
    start_snake_game();
                    

    TFT_SET_Brush(1, CL_RED, 0, 0, 0 ,0);
    TFT_Rectangle(0, 0, 320, 240);
    TFT_Fill_Screen(CL_RED);

    Delay_ms(3000);

    while (1) {
        // load_intro_screen();
    }
}